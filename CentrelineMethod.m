function Results=CentrelineMethod(centreline,termini,termini_date)

% CentrelineMethod
% 'Centreline' = centreline shapefile data that have already been read in to
% Matlab; 'termini' = terminus data that have already been read into Matlab;
% 'termini_date' = data extracted from termini shapefiles by readGlacierData
% function.
% Function calculates the shortest path distance along a defined
% centreline between termini. Output is given in meters from the the start
% of the centreline, with each row corresponding to the date given in the
% termini_date variable that can be generated by executing the
% readGlacierData function.

    method_name='Centreline method';
    %determine points of intercept between the termini and the centreline
%     term_intercept_x=nan(length(termini(:,1)),100); %creates empty matrix in case of multiple intercepts
%     term_intercept_y=nan(length(termini(:,1)),100); %creates empty matrix in case of multiple intercepts
    for n=1:length(termini(:,1))
        [term_intercept_dummyx,term_intercept_dummyy]=polyxpoly(centreline.X,...
            centreline.Y,termini{n,1}.X,termini{n,1}.Y);
        term_intercept_x(n,1:length(term_intercept_dummyx))=term_intercept_dummyx';
        term_intercept_y(n,1:length(term_intercept_dummyy))=term_intercept_dummyy';
    end
    term_intercept_x(term_intercept_x==0)=NaN;
    term_intercept_y(term_intercept_y==0)=NaN;
    
    a=0;
    %determine the distance along the flowline
    h=waitbar(0,'Calculating...')
    for n=1:length(termini(:,1))
        for p=1:length(term_intercept_x(1,:))   %to take account where there are multiple intercepts
        distance_raw(n,p)=0;
        cutoff=0;
        for m=1:length(centreline.X)-1
          if cutoff==0
              if ~isnan(term_intercept_x(n,p)) && term_intercept_x(n,p)~=0
                %compares if linear distance between centreline nodes or
                %between a node, and works way along centreline until intercept
                %is reached.
                dist_to_point=sqrt(((centreline.X(1,m+1)-centreline.X(1,m))^2)...
                    +((centreline.Y(1,m+1)-centreline.Y(1,m))^2));
                dist_to_intercept=sqrt(((term_intercept_x(n,p)-centreline.X(1,m))^2)...
                    +((term_intercept_y(n,p)-centreline.Y(1,m))^2));
                if dist_to_point<dist_to_intercept
                    distance_raw(n,p)=distance_raw(n,p)+dist_to_point;
                    centreline1{n,p}(m,1:2)=[centreline.X(m),centreline.Y(m)];
                elseif dist_to_point>dist_to_intercept || length(centreline.X)==2
                    centreline1{n,p}(m,1:2)=[term_intercept_x(n,p),term_intercept_y(n,p)];
                    distance_raw(n,p)=distance_raw(n,p)+dist_to_intercept;
                    cutoff=1;
                end
              else
                 distance_raw(n,p)=NaN;
              end
          end
        end
        
        end
    %calculate straight line and path widths of the termini    
        for m=1:length(termini{n}.X)-1
            node_dist(m,1)=((termini{n}.Y(m)-termini{n}.Y(m+1))^2+(termini{n}.X(m)-termini{n}.X(m+1))^2)^0.5;
        end
        terminus_length(n,1)=sum(node_dist(:,1));
        
        %Get indicies of centreline lengths, taking shortest centreline
        %length where there are multiple intercepts.
        
        if distance_raw(n,1)>0  %leaves out termini where there is no intercept with centreline
        a=a+1;
           
           Results.Method=method_name;
            Results.Date(a,:)=termini_date(n,1:end);
            %calculate straight line width of terminus
            Results.TerminusWidth(a,1)=((termini{n}.X(1)-termini{n}.X(end-1))^2+...
                (termini{n}.Y(1)-termini{n}.Y(end-1))^2)^0.5;
            %calculate the path length along the glacier terminus.
            Results.TerminusPathLength(a,1)=terminus_length(n,1);
            [Results.RawDistance(a,1),ind]=nanmin(distance_raw(n,:));
            Results.CentrelineCut{a,1}=centreline1{n,ind};
            Results.TerminusGeometry{a,1}=[termini{n}.X';termini{n}.Y'];
            Results.TerminusDetail(a,1)=terminus_length(n,1)/length(Results.TerminusGeometry{a,1}(1,:));
        end
        waitbar(n/length(termini(:,1)))
    end

         Results.Centreline(:,1)=centreline.X;
        Results.Centreline(:,2)=centreline.Y;
        Results.Distance=Results.RawDistance-Results.RawDistance(end,1);
        Results.TerminusChange(1,1)=nan;
%         Results.RateChange(n,1)=nan;    
        for n=2:length(Results.Distance(:,1))
            %calculate terminus change
            Results.TerminusChange(n,1)=Results.Distance(n,1)-Results.Distance(n-1,1);
            %calculate rate of terminus change in m/yr
            Results.RateChange(n,1)=Results.TerminusChange(n,1)/...
                ((termini_date(n,4)-termini_date(n-1,4))/365);
        end
        
    close(h)
end